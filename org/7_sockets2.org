* Objectives

The following topics are covered:

- [ ] What are port numbers?
- [ ] How to find port numbers on Linux?
- [ ] What is the client-server model?
- [ ] What's a socket?
- [ ] What's your IP address?
- [ ] How can you list network adapters using C?

* Port numbers

- How does a packet know, which application is responsible for it
  once it arrives at a specific system?

- To direct a packet to the right application, *port* numbers are
  used. If IP addresses are phone numbers, then port numbers are like
  phone extensions.

- Applications on your system with specific ports:
  + multiple web browsers
  + an email client
  + a video-conferencing client

- When a packet arrives, the OS looks at the destination port number,
  and it is used to determine which application could handle it.

- Port numbers are stored as unsigned 16-bit integers - what's their
  range therefore?
  #+begin_src R
    2^16
  #+end_src

  #+RESULTS:
  : 65536

- Some port numbers for common protocols:
  #+attr_html: :width 700px:
  [[../img/ports.png]]

- The listed port numbers are assigned by the IANA (Internet Assigned
  Numbers Authority).

* Linux example

- To see some of these in Linux:
  #+begin_src bash :results output :exports both
    netstat -tulnp
  #+end_src

  #+RESULTS:
  #+begin_example
  Active Internet connections (only servers)
  Proto Recv-Q Send-Q Local Address           Foreign Address    State       PID/Program name
  tcp        0      0 127.0.0.1:631           0.0.0.0:*          LISTEN      -
  tcp        0      0 127.0.0.53:53           0.0.0.0:*          LISTEN      -
  tcp6       0      0 :::1716                 :::*               LISTEN      1847/kdeconnectd
  tcp6       0      0 ::1:631                 :::*               LISTEN      -
  udp        0      0 127.0.0.53:53           0.0.0.0:*                      -
  udp        0      0 0.0.0.0:35912           0.0.0.0:*                      -
  udp        0      0 224.0.0.251:5353        0.0.0.0:*                      41742/chrome
  udp        0      0 0.0.0.0:5353            0.0.0.0:*                      -
  udp6       0      0 :::1716                 :::*                           1847/kdeconnectd
  udp6       0      0 :::5353                 :::*                           -
  udp6       0      0 :::56953                :::*                           -
  #+end_example

  On my machine at home (PIDs not listed):
  #+begin_example
  Active Internet connections (only servers)
  Proto Recv-Q Send-Q Local Address           Foreign Address    State
  tcp        0      0 127.0.0.53:53           0.0.0.0:*          LISTEN
  tcp        0      0 127.0.0.1:631           0.0.0.0:*          LISTEN
  tcp6       0      0 :::60000                :::*               LISTEN
  tcp6       0      0 ::1:631                 :::*               LISTEN
  udp        0      0 127.0.0.53:53           0.0.0.0:*
  udp        0      0 127.0.0.1:323           0.0.0.0:*
  udp        0      0 224.0.0.251:5353        0.0.0.0:*
  udp        0      0 224.0.0.251:5353        0.0.0.0:*
  udp        0      0 224.0.0.251:5353        0.0.0.0:*
  udp        0      0 224.0.0.251:5353        0.0.0.0:*
  udp        0      0 0.0.0.0:5353            0.0.0.0:*
  udp        0      0 0.0.0.0:46510           0.0.0.0:*
  udp6       0      0 ::1:323                 :::*
  udp6       0      0 fe80::3411:8f1:989f:546 :::*
  udp6       0      0 :::5353                 :::*
  udp6       0      0 :::47923                :::*
  #+end_example

- Web server example (do this on the shell):
  1) start a web server with ~python3~ on port ~8080~
  2) ~grep~ for ~8080~ in the ~netstat -tulnp~ output
  #+begin_example sh
  python3 -m http.server 8080 &
  netstat -tulnp | grep 8080
  #+end_example

- Output:
  #+begin_example
  tcp  0  0 0.0.0.0:8080 0.0.0.0:* LISTEN  274074/python3
  #+end_example

* Clients and servers
#+attr_html: :width 700px:
#+caption: 2-client-1-server network in Cisco Packet Tracer
[[../img/pt_network.png]]

- When you use a telephone, a call must be initiated by one party. The
  initiating party dials the number for the receiving party, and the
  receiving party answers.

- This describes the *client-server* model paradigm in networking:
  1) A server listens for connections.
  2) The client knows the address and port number that the server is
     listening to and establishes connection by sending the first
     packet.

- Example: Web server
  #+begin_quote
  1) The web server at ~example.com~ listens on port ~80~ (HTTP) and on
     port ~443~ (HTTPS) for connections.
  2) A web browser (client) establishes the connection by sending the
     first packet to ~http://example.com:80~.
  #+end_quote

* Sockets

- A *socket* is one end-point of a communication link. It enables
  sending and receiving data over the network.

- An open socket is defined by a quintuple (5-tuple):
  1. Local IP address
  2. Local port
  3. Remote IP address
  4. Remote port
  5. Protocol (UDP or TCP)

- With this information, the OS knows which application is responsible
  for any packets received.

- Example: You have two web browsers (Chrome and Firefox) open
  simultaneously, both connecting to ~example.com~ on port ~80~. How can
  the OS keep the connections separate?
  #+begin_quote
  The OS keeps the connections separate by looking at the socket
  data. In this case, local and remote IP addresses, remote port and
  protocol are identical but the local port is different. The local
  (aka *ephemeral*) port was chosen to be different by the OS for the
  connection.
  #+end_quote

- The router NAT (Network Address Translation) also stores the socket
  5-tuple to know how to route received packets back into the private
  network.

- Take a look at the ~socket~ man page on Linux. What does it do?
  #+begin_quote
  The function ~socket()~ creates an endpoint for communication and
  returns a *file descriptor* that refers to that endpoint.  The file
  descriptor returned by a successful call will be the lowest-numbered
  file descriptor not currently open for the process.
  #+end_quote

- What is a "file descriptor"?
  #+begin_quote
  For the OS (any OS), everything is a "file". The file descriptor is
  a small non-negative integer that uniquely identifies a socket
  within a process. When calling ~socket~, you get a descriptor that you
  can use to perform operations on that socket (binding, listening,
  accepting, reading, and writing).
  #+end_quote

- How does a ~socket~ call look like?
  #+name: socket_prototype
  #+begin_example C
  // socket: establish network connection to listen on
  // returns: file descriptor (int)
  // params: domain (protocol family), type (data stream),
  //         protocol (TCP or UDP or another)
  int socket(int domain, int type, int protocol);
  #+end_example
  #+begin_quote
  For example:
  - =domain = AF_STREAM= (Address Family - Internet: using IPv4 address)
  - =type = SOCK_STREAM= (Socket Type - TCP)
  - =protocol = 0= (automatically select the protocol - TCP)
  #+end_quote

- Where is the 5-tuple?
  #+begin_quote
  The 5-tuple is completed when a client connects to a server, and a
  server accepts a client (functions ~connect~ and ~accept~).
  #+end_quote

- Before looking at socket programming, let's look at a similar
  abstraction, *file* handling.

